Index: app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import print_function\r\n\r\nimport datetime\r\nfrom datetime import timezone, timedelta\r\n# Python standard libraries\r\nimport json\r\nimport os.path\r\nimport random\r\nimport sqlite3\r\nfrom datetime import datetime, time\r\n\r\n# Third-party libraries\r\n# import base32hex\r\nimport flask\r\nimport requests\r\nfrom flask import Flask, redirect, request, url_for\r\nfrom flask_cors import CORS\r\nfrom flask_login import (\r\n    LoginManager,\r\n    current_user,\r\n    login_required,\r\n    login_user,\r\n    logout_user,\r\n)\r\nfrom oauthlib.oauth2 import WebApplicationClient\r\nimport Lineder_logging\r\n\r\n# from quickstart import main as flow_main\r\nimport quickstart\r\nfrom classes.Event import MyEvent as dbEvent\r\n# Internal imports\r\nfrom session_managment import SessionManagement, Unauthorized\r\nimport OneSignalConfig\r\nfrom db import init_db_command, get_db\r\nfrom dbUser import MyUser as DbUser\r\nfrom freebusy_range import Freebusy as Range\r\nfrom freebusy_range import TZ_DELTA, LOCAL_TIME_ZONE\r\nfrom user import User\r\nfrom ques import Ques\r\n\r\nWAITER_ADDRESS_HTTP_PARAM_NAME = 'waiter_address'\r\nSESSION_ID_HTTP_PARAM_NAME = 'session_id'\r\n\r\nsession = SessionManagement ()\r\n\r\nmy_logger = Lineder_logging.get_logger (\"App\")\r\nmy_logger.debug (\"\\n--------------------------- NEW ---------------------------\\n\")\r\nmy_logger.debug (\"Starting Logging\")\r\n\r\n# My custom classes\r\n# from classes.Users import Users\r\n# from classes.User import MyUser\r\n# from classes.Event import MyEvent\r\n\r\n\r\n# class MyEvent:\r\n#     def __init__(self, title, start, end):\r\n#         self.end = end\r\n#         self.start = start\r\n#         self.title = title\r\n#\r\n#\r\n# class MyUser:\r\n#     def __init__(self, username, event_list):\r\n#         self.username = username\r\n#         self.event_list: List[Event] = event_list\r\n#\r\n#     def insert_new_event(self, new_event: MyEvent):\r\n#         self.event_list.append(new_event)\r\n#\r\n#     def set_event_list(self, new_event_list):\r\n#         self.event_list = new_event_list\r\n#\r\n#     def get_event_by_title(self, title):\r\n#         for event in self.event_list:\r\n#             if event.title == title:\r\n#                 return event\r\n#         return None\r\n#\r\n#\r\n# class Users:\r\n#     def __init__(self, user_list):\r\n#         self.user_list = user_list\r\n#\r\n#     def get_user_by_username(self, username: str) -> MyUser:\r\n#         for user in self.user_list:\r\n#             if user.username == username:\r\n#                 return user\r\n#         return None\r\n#\r\n#     def insert_new_user(self, new_user: MyUser):\r\n#         # if not self.user_list:  # check if first item in the list is '[]'\r\n#         # if so, insert the user into that spot\r\n#         #     self.user_list[0] = new_user\r\n#         if new_user not in self.user_list:\r\n#             self.user_list.append(new_user)\r\n#\r\n#     def update_user_event_list(self, username, new_event_list):  # : List[Event]\r\n#         for user in self.user_list:\r\n#             if user.username == username:\r\n#                 pass\r\n#             else:\r\n#                 return None\r\n#         for user in self.user_list:\r\n#             if user.username == username:\r\n#                 user.event_list = new_event_list\r\n\r\nHEX32_MAX = 111111111\r\n\r\n# Configuration\r\nSCOPES = ['https://www.googleapis.com/auth/calendar.readonly']\r\n\r\n# Google API Credentials\r\n# The client ID created for the app in the Google Developers Console\r\n# with the google-signin-client_id meta element\r\n# GOOGLE_CLIENT_ID = \"701150580333-9lqf3ot4ptha6k80j942km8l5pq5hd2s.apps.googleusercontent.com\"\r\n# GOOGLE_CLIENT_SECRET = \"CnWxlsvrnLi9Wbmdk2Txb6ES\"\r\nGOOGLE_CLIENT_ID = os.environ.get (\"GOOGLE_CLIENT_ID\", None)\r\nGOOGLE_CLIENT_SECRET = os.environ.get (\"GOOGLE_CLIENT_SECRET\", None)\r\nGOOGLE_DISCOVERY_URL = (\r\n    \"https://accounts.google.com/.well-known/openid-configuration\"\r\n)\r\n\r\n# In memory DB initialization\r\n# users = Users([])\r\n\r\n\r\n# Flask app setup\r\napp = Flask(__name__)\r\napp.config['supports_credentials'] = True\r\n# app.config['SESSION_COOKIE_HTTPONLY'] = False\r\nprint(\"app config:\", app.config)\r\ncors = CORS(app, resources={r\"/api/*\": {\"origins\": \"*\"}}, supports_credentials=True)\r\napp.secret_key = os.environ.get(\"SECRET_KEY\") or os.urandom(24)\r\nunauthorized_resp = None\r\n\r\n\r\n\r\n# User session management setup\r\n# https://flask-login.readthedocs.io/en/latest\r\nlogin_manager = LoginManager ()\r\nlogin_manager.init_app (app)\r\nmy_logger.debug(\"Going to initialize DB\")\r\n# Naive database setup\r\ntry:\r\n    my_logger.debug(\"creating DB\")\r\n    init_db_command ()\r\n    # db = get_db()\r\n    #\r\n    # db.execute(\"DROP TABLE MyUser\")\r\n    # db.execute(\"DROP TABLE Ques\")\r\n    # db.execute(\"DROP TABLE freebusy\")\r\n    # print(\"dropped all\")\r\nexcept sqlite3.OperationalError:\r\n    # Assume it's already been created\r\n    my_logger.debug(\"DB already created\")\r\n\r\n# OAuth 2 client setup\r\n# print(GOOGLE_CLIENT_ID)\r\n# print(GOOGLE_CLIENT_SECRET)\r\nclient = WebApplicationClient(GOOGLE_CLIENT_ID)\r\n\r\n\r\nclass Event:\r\n    def __init__(self,  title, start, end):\r\n        self.start = start\r\n        self.end = end\r\n        self.title = title\r\n\r\n    def __repr__(self):\r\n        return str(self.start) + \"  -  \" + str(self.end) + \"   |   \" + str(self.title)\r\n\r\n    def make_json(self):\r\n        \"\"\"\r\n        Serializes the event as a JSON\r\n        :return: the JSON in a string\r\n        \"\"\"\r\n        # return \"title:\" + str(self.title) + \", \\n\" + \"start:\"\r\n        return str(flask.jsonify(\r\n            title=self.title,\r\n            start=self.start,\r\n            end=self.end\r\n        ))\r\n\r\n    def serialize(self):\r\n        \"\"\"\r\nThis is where the JSON magic happens.\r\nThis is the dictionary that specifies how to serialized the class.\r\n        :return:\r\n        \"\"\"\r\n        return {\r\n            'title': self.title,\r\n            'start': self.start,\r\n            'end': self.end\r\n        }\r\n\r\n\r\nclass EventsList:\r\n    def __init__(self, events):\r\n        self.events_list = events\r\n        self.events_list_arranged = []\r\n        self.events_list_json = []\r\n\r\n    def __repr__(self):\r\n        \"\"\"\r\n        Represent the class as a string\r\n        :return: \r\n        A string with a list of events\r\n        \"\"\"\r\n        events_string: str = \"\"\r\n        for i, event in enumerate(self.events_list_arranged):\r\n            events_string += event.__repr__() + \", \"\r\n        return events_string\r\n\r\n    def make_json(self):\r\n        # return json.dumps(self.events_list_arranged)\r\n        for event in self.events_list_arranged:\r\n            self.events_list_json.append(event.make_json())\r\n        return flask.jsonify(\r\n            events=self.events_list_json\r\n        )\r\n\r\n    def arrange_events(self, owner_id):\r\n        if not self.events_list:\r\n            my_logger.debug('No upcoming events found.')\r\n\r\n        for i, event in enumerate(self.events_list):\r\n            event_id = event['id']\r\n            start = event['start'].get('dateTime', event['start'].get('date'))\r\n            end = event['end'].get('dateTime', event['start'].get('date'))\r\n            title = event['summary']\r\n            new_event = dbEvent(event_id, owner_id, title, start, end)\r\n            print(\"\\nevent number:\", i)\r\n            print(new_event)\r\n            self.events_list_arranged.append(new_event)\r\n            # print(start, \" - \", end, \" | \", event['summary'])\r\n        print(\"\\n\\nevents list arranged in arrange_events:\\n\" + self.__repr__())\r\n\r\n\r\n# Flask-Login helper to retrieve a user from our db\r\n@login_manager.user_loader\r\ndef load_user(user_id):  # actually gets email instead of id\r\n    # user_id = DbUser.get_id_by_email(user_address)\r\n    my_logger.debug(\"\\nLOAD USER %s\", DbUser.get(user_id))\r\n    return DbUser.get(user_id)\r\n\r\n\r\n@app.route(\"/json_test\")\r\ndef json_test():\r\n    return flask.jsonify(\r\n        redirect_url=\"hello\",\r\n        code=302\r\n    )\r\n\r\n\r\n@app.route(\"/\")\r\ndef index():\r\n    global unauthorized_resp\r\n    message = {'error': 'Unauthorized'}\r\n    unauthorized_resp = flask.jsonify(message)\r\n    unauthorized_resp.status_code = 401\r\n    # if current_user.is_authenticated:\r\n    #     return (\r\n    #         \"<p>Hello, {}! You're logged in! Email: {}</p>\"\r\n    #         \"<div><p>Google Profile Picture:</p>\"\r\n    #         '<img src=\"{}\" alt=\"Google profile pic\"></img></div>'\r\n    #         '<div><a class=\"button\" href=\"/getEvents\">Get Events</a></div>'\r\n    #         '<div><p></p></div>'\r\n    #         '<a class=\"button\" href=\"/logout\">Logout</a>'.format(\r\n    #             current_user.name, current_user.email, current_user.profile_pic\r\n    #         )\r\n    #     )\r\n    # else:\r\n    #     return '<a class=\"button\" href=\"/login\">Google Login</a>'\r\n    return redirect(url_for(\"login_flow\"))\r\n\r\n\r\ndef get_google_provider_cfg():\r\n    return requests.get(GOOGLE_DISCOVERY_URL).json()\r\n\r\n\r\n@app.route(\"/getEvents\")\r\n@login_required\r\ndef get_events():\r\n    now = datetime.datetime.utcnow().isoformat() + 'Z'  # 'Z' indicates UTC time\r\n    url = 'https://www.googleapis.com/calendar/v3/calendars/primary/events?maxResults=5&timeMin=' + now\r\n    req = requests.Session()\r\n    my_logger.debug(client.token)\r\n    token = client.token.get(\"access_token\")\r\n    my_logger.debug(token)\r\n    req = requests.get(url, headers={'Authorization': 'Bearer %s' % token}, data=None)\r\n    my_logger.debug(\"\\nresponse: %s\", req.text)\r\n    with open(\"sample.txt\", \"w\", encoding=\"utf-8\") as text_file:\r\n        text_file.write(req.text)\r\n    return redirect(url_for(\"index\"))\r\n\r\n\r\n@app.route(\"/login\")  # arrow 1\r\ndef login_flow():\r\n    \"\"\"\r\n    login_flow starts the login process and then redirects the user to the next stage by sending a 302 redirect\r\n    response with the URL received from quickstart\r\n    :return:\r\n        The redirect response\r\n    \"\"\"\r\n    params = flask.request.args\r\n    session_id = params.get('session_id')\r\n    if not session_id:\r\n        # TODO:\r\n        # token, creds - not used below\r\n        token, creds, url = quickstart.until_url()\r\n        return redirect(url, code=302)\r\n    if session.is_logged_in(session_id):\r\n        return \"You are already logged in. You can close this window\"\r\n    token, creds, url = quickstart.until_url()\r\n    return redirect(url, code=302)  # arrow 4 + 5\r\n\r\n\r\n# Original 'login' code\r\ndef login():\r\n    # Find out what URL to hit for Google login\r\n    google_provider_cfg = get_google_provider_cfg()\r\n    authorization_endpoint = google_provider_cfg[\"authorization_endpoint\"]\r\n    # Use library to construct the request for Google login and provide\r\n    # scopes that let you retrieve user's profile from Google\r\n    request_uri = client.prepare_request_uri(\r\n        authorization_endpoint,\r\n        redirect_uri=request.base_url + \"/new_callback\",\r\n        scope=[\"openid\", \"email\", \"profile\", 'https://www.googleapis.com/auth/calendar.readonly'],\r\n    )\r\n    return redirect(request_uri)\r\n\r\n\r\n# @app.route(\"/login/callback\", methods=['OPTIONS'])\r\n# def deal_with_options_request():\r\n#     if request.method == 'OPTIONS':\r\n#         print(\"sent 200 OK\")\r\n#         resp = jsonify(success=True, status_code=200)\r\n#         print(resp)\r\n#         # return json.dumps({'success': True}), 200, {'ContentType': 'application/json'}\r\n#         return resp\r\n\r\n# @app.route(methods=['OPTIONS'])\r\n# def deal_with_options_request():\r\n#     return 201, {'Access-Control-Allow-Origin': '*'}\r\n\r\n\r\n@app.after_request\r\ndef after_request(response):\r\n    # my_logger.debug(\"after request\")\r\n    response.headers.add('Access-Control-Allow-Origin', '*')\r\n    # response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,Access-Control-Allow-Origin')\r\n    response.headers.add('Access-Control-Allow-Headers', '*')\r\n    response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS')\r\n    response.headers.add('Access-Control-Allow-Credentials', 'true')\r\n    return response\r\n    # return response\r\n\r\n\r\n# @app.after_request\r\n# def after_request(response):\r\n#     response.headers.add('Access-Control-Allow-Origin', '*')\r\n#     response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')\r\n#     response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE')\r\n#     return response\r\n\r\n\r\n# @app.route(\"/login/callback\")\r\n# def callback():\r\n#     \"\"\"\r\n#     Callback is being called by Google API when the user is authenticated. Once the user is authenticated,\r\n#     it arranges the events and created the JSON response with the list of events\r\n#     \"\"\"\r\n#     global users\r\n#     print(\"CALLBACK\")\r\n#     after_url_events, user_address = quickstart.after_url()  # get user events + email address\r\n#     events_list = EventsList(after_url_events)  # creds, token\r\n#     events_list.arrange_events()\r\n#     # print(len(events_list.events_list_arranged))\r\n#     final_events = events_list.events_list_arranged\r\n#\r\n#     print(\"\\nResponse:\\n\", final_events)\r\n#     user = MyUser(user_address, final_events)\r\n#\r\n#     res = flask.jsonify(\r\n#         events=[event.serialize() for event in user.event_list]\r\n#     )\r\n#     print(\"\\nuser events:\", user.event_list)\r\n#     # set a cookie with the username so that we can use it later in the 'new_event' endpoint\r\n#     res.set_cookie('user_address', user.username)\r\n#     users.insert_new_user(user)\r\n#     # print(res)\r\n#     return res\r\n\r\n\r\n@app.route(\"/show_cookie\")\r\ndef show_cookie():\r\n    # return \"hello\"\r\n    username = flask.request.cookies.get('user_address')\r\n    res = flask.jsonify(username=username)\r\n    my_logger.debug(username)\r\n    return res\r\n\r\n\r\n# http://127.0.0.1:5000/new_event?title=text&start=1000&end=1100\r\n# @app.route(\"/new_event\")  # , methods=['POST']\r\n# def add_new_event ():\r\n#     # global users\r\n#     username = flask.request.cookies.get ('user_address')\r\n#     if not username:\r\n#         print(\"Username Not Found\")\r\n#         return flask.jsonify(success=False)\r\n#     print(username)\r\n#     params = flask.request.args\r\n#     title = params.get('title')\r\n#     start = params.get('start')\r\n#     end = params.get('end')\r\n#     new_event = Event(title, start, end)\r\n#     print(\"\\nNEW EVENT ADDED:\", new_event)\r\n#     my_current_user = users.get_user_by_username(username)\r\n#     my_current_user.insert_new_event(new_event)\r\n#     # print(users)\r\n#     print(\"\\nmy events:\", my_current_user.event_list)\r\n#     return flask.jsonify(success=True)\r\n\r\n\r\n@app.route(\"/login/new_callback\")\r\ndef ranges_callback():\r\n    # print(\"headers:\", flask.request.headers)\r\n    # phone = flask.request.args.get('phone')\r\n    my_logger.debug(\"ranges callback\")\r\n    freebusy, user_address, name, phone = quickstart.after_url()\r\n    cur_user = DbUser(user_address, name, phone)  # current user\r\n    my_logger.debug(\"cUser after constructor:\")\r\n    my_logger.debug(cur_user)\r\n    cur_user.id = DbUser.get_id_by_email(user_address)\r\n    my_logger.debug(\"user.id in callback: %s\", cur_user.id)\r\n    if not cur_user.id:\r\n        # TODO:\r\n        # You are missing two parameters here for create: name and phone\r\n        cUser_id = DbUser.create(cur_user.email)\r\n\r\n    # logging in the user\r\n    session_id = session.login_user(user_address)\r\n    my_logger.debug(session.users_dict)\r\n    my_logger.debug(\"LOGGED IN NEW USER!\")\r\n    my_logger.debug(\"email: %s\",cur_user.email)\r\n    my_logger.debug(\"user_id: %s\",cur_user.id)\r\n    my_logger.debug(\"\\nUser: %s\", user_address)\r\n    my_logger.debug(freebusy)\r\n\r\n    # Create the ranges in our database\r\n    for c_range in freebusy:\r\n        Range.create_range(cur_user.id, c_range['start'], c_range['end'])\r\n\r\n    # Build the HTTP response\r\n    res = flask.jsonify(freebusy=freebusy, name=name, phone=phone, session_id=session_id)\r\n    my_logger.debug(\"callback response: %s\", res.get_data(as_text=True))\r\n    return res\r\n\r\n\r\n# @app.route(\"/login/og_callback\")\r\n# def og_callback():\r\n#     my_logger.debug(\"OG CALLBACK\")\r\n#\r\n#     # Get authorization code Google sent back to you\r\n#     code = request.args.get(\"code\")\r\n#     my_logger.debug(\"code:\", code)\r\n#\r\n#     # Find out what URL to hit to get tokens that allow you to ask for\r\n#     # things on behalf of a user\r\n#     google_provider_cfg = get_google_provider_cfg()\r\n#     token_endpoint = google_provider_cfg[\"token_endpoint\"]\r\n#\r\n#     # Prepare and send a request to get tokens! Yay tokens!\r\n#     token_url, headers, body = client.prepare_token_request(\r\n#         token_endpoint,\r\n#         authorization_response=request.url,\r\n#         redirect_url=request.base_url,\r\n#         code=code\r\n#     )\r\n#     token_response = requests.post(\r\n#         token_url,\r\n#         headers=headers,\r\n#         data=body,\r\n#         auth=(GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET),\r\n#     )\r\n#     # Parse the tokens!\r\n#     client.parse_request_body_response(json.dumps(token_response.json()))\r\n#\r\n#     # Now that you have tokens (yay) let's find and hit the URL\r\n#     # from Google that gives you the user's profile information,\r\n#     # including their Google profile image and email\r\n#     userinfo_endpoint = google_provider_cfg[\"userinfo_endpoint\"]\r\n#     uri, headers, body = client.add_token (userinfo_endpoint)\r\n#     userinfo_response = requests.get (uri, headers=headers, data=body)\r\n#     # You want to make sure their email is verified.\r\n#     # The user authenticated with Google, authorized your\r\n#     # app, and now you've verified their email through Google!\r\n#     if userinfo_response.json ().get (\"email_verified\"):\r\n#         unique_id = userinfo_response.json ()[\"sub\"]\r\n#         users_email = userinfo_response.json ()[\"email\"]\r\n#         picture = userinfo_response.json ()[\"picture\"]\r\n#         users_name = userinfo_response.json ()[\"given_name\"]\r\n#     else:\r\n#         return \"User email not available or not verified by Google.\", 400\r\n#\r\n#     # Create a user in your db with the information provided\r\n#     # by Google\r\n#     user = User(\r\n#         id_=unique_id, name=users_name, email=users_email, profile_pic=picture\r\n#     )\r\n#     # Doesn't exist? Add it to the database.\r\n#     if not User.get(unique_id):\r\n#         User.create(unique_id, users_name, users_email, picture)\r\n#     # Begin user session by logging the user in\r\n#     login_user(user)\r\n#\r\n#     \"\"\" Get the user's calendar events (same as the userinfo but with a different endpoint) \"\"\"\r\n#     # Get user events + gmail address\r\n#     after_url_events, user_address = quickstart.after_url ()\r\n#     with open (\"sample.txt\", \"w\", encoding=\"utf-8\") as text_file:\r\n#         text_file.write (str (after_url_events))\r\n#     c_user = DbUser (user_address)  # current user\r\n#     if not c_user.get ():\r\n#         c_user.create ()\r\n#     # Begin user session by logging the user in\r\n#     login_user (c_user)\r\n#     events = EventsList (after_url_events)\r\n#     events.arrange_events (user_address)\r\n#     final_events = events.events_list_arranged\r\n#     print(\"FINAL EVENTS in new:\\n\", final_events)\r\n#     \"\"\" Insert new events to db \"\"\"\r\n#     for event in final_events:\r\n#         if not dbEvent.get_event(event.event_id):\r\n#             dbEvent.create(event.event_id, current_user.id, event.title, event.start, event.end)\r\n#     #  construct response\r\n#     res = flask.jsonify(\r\n#         events=[event.serialize() for event in final_events]\r\n#     )\r\n#     return res\r\n#     # google_calendar_endpoint = SCOPES\r\n#     # uri, headers, body = client.add_token(google_calendar_endpoint)\r\n#     # calendar_response = requests.get(uri, headers=headers, data=body)\r\n#     # events_list = EventsList(calendar_response)  # creds, token\r\n#     # events_list.arrange_events()\r\n#     # # print(len(events_list.events_list_arranged))\r\n#     # final_events = events_list.events_list_arranged\r\n\r\n\r\n# @app.route(\"/new_event\")\r\n# # @login_required\r\n# def new_event():\r\n#     new_event_id = randomize_new_event_id()\r\n#     params = flask.request.args\r\n#     new_event = dbEvent(new_event_id, current_user.id, params.get('title'),\r\n#                         params.get('start'), params.get('end'))\r\n#     if not dbEvent.get_event(new_event.event_id):\r\n#         dbEvent.create(new_event.event_id, current_user.id, new_event.title,\r\n#                        new_event.start, new_event.end)\r\n#     success = dbEvent.get_event(new_event.event_id)\r\n#     res = flask.jsonify(success=success)\r\n#     return res\r\n\r\n\r\n@app.route(\"/busy_for\")\r\ndef busy_for():\r\n    params = flask.request.args\r\n    session_id = params.get (SESSION_ID_HTTP_PARAM_NAME)\r\n    try:\r\n        owner_id = session.handle_user_user_id(session_id)\r\n    except Unauthorized:\r\n        return unauthorized_resp\r\n    hours = int(params.get('hours'))\r\n    mins = int(params.get('mins'))\r\n    success = Range.busy_for(owner_id, hours, mins)\r\n    res = flask.jsonify(success=success)\r\n    return res\r\n\r\n# /new_range?start=1985-04-12T23:20:50.52Z&end=1985-05-12T23:20:50.52Z\r\n# from 12.04.1985, 23:20:50.52 until 12.05.1985, 23:20:50.52\r\n@app.route(\"/new_range\")\r\n# @login_required\r\ndef new_range():\r\n    params = flask.request.args\r\n    session_id = params.get (SESSION_ID_HTTP_PARAM_NAME)\r\n    try:\r\n        owner_id = session.handle_user_user_id(session_id)\r\n    except Unauthorized:\r\n        return unauthorized_resp\r\n    start: datetime = params.get('start')\r\n    end: datetime = params.get('end')\r\n    # owner_id = DbUser.get_id_by_email(current_user.email)\r\n    # owner_id = DbUser.get_id_by_email(\"roy.quitt@googlemail.com\")\r\n    # owner_id = current_user.id\r\n    # owner_address = session.get_address_by_session_id(session_id)\r\n    # owner_id = DbUser.get_id_by_email(owner_address)\r\n    print(start, end)\r\n    now = datetime.now(tz=timezone(timedelta(hours=2), 'IST'))\r\n    new_start: datetime = datetime.strptime(start, \"%H:%M\")\r\n    final_start = datetime(now.year, now.month, now.day, new_start.hour, new_start.minute).isoformat() + 'Z'\r\n    new_end: datetime = datetime.strptime(end, \"%H:%M\")\r\n    final_end = datetime(now.year, now.month, now.day, new_end.hour, new_end.minute).isoformat() + 'Z'\r\n    # final_start: datetime = datetime.strptime(start, \"%H:%M %Y-%m-%dT%H:%M:%SZ\")\r\n    # final_end: datetime = datetime.strptime(end, \"%H:%M %Y-%m-%dT%H:%M:%SZ\")\r\n    print(final_start, final_end)\r\n    success = Range.create_range(owner_id, final_start, final_end)\r\n    res = flask.jsonify(success=success)\r\n    return res\r\n\r\n\r\n# def randomize_new_event_id():\r\n#     # generate a random string in base32hex similar to the google unique event ID\r\n#     s = base32hex.b32encode(random.randint(HEX32_MAX))\r\n#     while dbEvent.get_event(s):\r\n#         s = base32hex.b32encode(random.randint(HEX32_MAX))\r\n#     return s\r\n\r\n\r\n@app.route(\"/get_user_schedule\")\r\ndef get_user_schedule():\r\n    \"\"\"\r\nRetrieve the availability of the user\r\nreturn value is JSON\r\n    @rtype: object\r\n    \"\"\"\r\n    params = flask.request.args\r\n    user_address = params.get('user_address')\r\n    print(\"User address in get user schedule:\" + user_address)\r\n    try:\r\n        user_ranges: list[tuple[datetime, datetime]] = DbUser.get_user_ranges(user_address)\r\n    except TypeError:\r\n        print(\"type error\")\r\n        return flask.jsonify(error=\"type error\")\r\n    # print(\"type of start:\", type(user_ranges[1]))\r\n    is_available: bool = DbUser.is_available(user_address)\r\n    next_available: datetime = DbUser.next_available(user_address)\r\n    phone = DbUser.get_user_phone(user_address)\r\n    name = DbUser.get_user_name(user_address)\r\n    res = flask.jsonify(\r\n        name=name,\r\n        ranges=user_ranges,\r\n        is_available=is_available,\r\n        next_available=next_available,\r\n        phone=phone\r\n    )\r\n    # Range.clean_db()\r\n    # Range.print_table()\r\n    return res\r\n\r\n\r\n@app.route(\"/join_que\")\r\n# @login_required\r\ndef join():\r\n    params = flask.request.args\r\n    session_id = params.get (SESSION_ID_HTTP_PARAM_NAME)\r\n    try:\r\n        waiter_address = session.handle_user(session_id)\r\n    except Unauthorized:\r\n        return unauthorized_resp\r\n    callee_address = params.get('user_address')\r\n    print(\"adding\", waiter_address, \"to\", callee_address + \"'s que\")\r\n    place_in_line = Ques.create_que_item(callee_address, waiter_address)\r\n    success = place_in_line != 0\r\n    res = flask.jsonify(\r\n        success=success,\r\n        place_in_line=place_in_line\r\n    )\r\n    return res\r\n\r\n\r\n@app.route(\"/move_to_top\")\r\n# @login_required\r\ndef move_to_top():\r\n    params = flask.request.args\r\n    session_id = params.get (SESSION_ID_HTTP_PARAM_NAME)\r\n    try:\r\n        callee_address = session.handle_user(session_id)\r\n    except Unauthorized:\r\n        return unauthorized_resp\r\n    # callee_address = current_user.email\r\n    waiter_address = params.get (WAITER_ADDRESS_HTTP_PARAM_NAME)\r\n    # waiter_address = \"roy.quitt@googlemail.com\"\r\n    # waiter_address = \"maibasis@gmail.com\"\r\n    # waiter_address = \"R0586868610@gmail.com\"\r\n    success = Ques.move_to_top(waiter_address, callee_address)\r\n    res = flask.jsonify(\r\n        success=success\r\n    )\r\n    return res\r\n\r\n\r\n@app.route(\"/remove_from_que\")\r\ndef remove():\r\n    params = flask.request.args\r\n    session_id = params.get (SESSION_ID_HTTP_PARAM_NAME)\r\n    try:\r\n        callee_address = session.handle_user(session_id)\r\n    except Unauthorized:\r\n        return unauthorized_resp\r\n    waiter_address = params.get (WAITER_ADDRESS_HTTP_PARAM_NAME)\r\n    success = Ques.remove_from_que (callee_address, waiter_address)\r\n    res = flask.jsonify (\r\n        success=success\r\n    )\r\n    return res\r\n\r\n\r\n@app.route(\"/get_my_que\")\r\n# @login_required\r\ndef get_my_que():\r\n    params = flask.request.args\r\n    session_id = params.get (SESSION_ID_HTTP_PARAM_NAME)\r\n    try:\r\n        address = session.handle_user(session_id)\r\n    except Unauthorized:\r\n        return unauthorized_resp\r\n    # address = current_user.email\r\n    print(\"getting que of:\", address)\r\n    # address = \"roy.quitt@googlemail.com\"\r\n    # address = \"maibasis@gmail.com\"\r\n    # address = \"R0586868610@gmail.com\"\r\n    user_que = Ques.get_my_que(address)\r\n    print([waiter.serialize() for waiter in user_que])\r\n    res = flask.jsonify(\r\n        que=[waiter.serialize() for waiter in user_que]\r\n    )\r\n    return res\r\n\r\n\r\n@app.route(\"/get_update\")\r\n# @login_required\r\ndef get_update():\r\n    params = flask.request.args\r\n    session_id = params.get (SESSION_ID_HTTP_PARAM_NAME)\r\n    try:\r\n        user_address = session.handle_user(session_id)\r\n    except Unauthorized:\r\n        return unauthorized_resp\r\n    # user_address = current_user.email\r\n    notifications = Ques.get_notifications(user_address)\r\n    res = flask.jsonify(\r\n        notifications=[notification.serialize() for notification in notifications]\r\n    )\r\n    return res\r\n\r\n\r\n@app.route(\"/logout\")\r\n# @login_required\r\ndef logout():\r\n    \"\"\"\r\n    Logs the user out erases their session\r\n    :rtype:\r\n        Http Response\r\n    \"\"\"\r\n    params = flask.request.args\r\n    session_id = params.get (SESSION_ID_HTTP_PARAM_NAME)\r\n    try:\r\n        address = session.handle_user(session_id)\r\n    except Unauthorized:\r\n        return unauthorized_resp\r\n    my_logger.debug(\"logging user out...\")\r\n    my_logger.debug(address)\r\n    session.log_out(session_id)\r\n    # TODO:\r\n    # You are supposed to call is_logged_in with session_id\r\n    success = not session.is_logged_in()\r\n    res = flask.jsonify(\r\n        success=success\r\n    )\r\n    return res\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # app.run(host=\"10.50.1.146\")\r\n    app.run(ssl_context=\"adhoc\")\r\n\r\n# TODO:\r\n#   getting events using browser:\r\n#       flow - start_response = 127\r\n#       flow - host = localhost\r\n#       app - HTTPS, host = none\r\n#   .\r\n#   best android:\r\n#       app - HTTP, host = 10.50.1.146\r\n#       flow - host = localhost\r\n#       flow - start_response = 127 / 10.50.1.146\r\n#   .\r\n#   ERORR\r\n#       app - HTTP, host = 10.50.1.146\r\n#       flow - host = 10.50.1.146\r\n#       flow - start_response = app.wechange.co.uk\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app.py b/app.py
--- a/app.py	
+++ b/app.py	
@@ -144,7 +144,7 @@
 # Naive database setup
 try:
     my_logger.debug("creating DB")
-    init_db_command ()
+    init_db_command()
     # db = get_db()
     #
     # db.execute("DROP TABLE MyUser")
@@ -204,7 +204,7 @@
     def __repr__(self):
         """
         Represent the class as a string
-        :return: 
+        :return:
         A string with a list of events
         """
         events_string: str = ""
@@ -637,6 +637,7 @@
     next_available: datetime = DbUser.next_available(user_address)
     phone = DbUser.get_user_phone(user_address)
     name = DbUser.get_user_name(user_address)
+    print(is_available, next_available)
     res = flask.jsonify(
         name=name,
         ranges=user_ranges,
Index: .idea/codeStyles/codeStyleConfig.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/codeStyles/codeStyleConfig.xml b/.idea/codeStyles/codeStyleConfig.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/codeStyles/codeStyleConfig.xml	
@@ -0,0 +1,5 @@
+<component name="ProjectCodeStyleConfiguration">
+  <state>
+    <option name="PREFERRED_PROJECT_CODE_STYLE" value="Default" />
+  </state>
+</component>
\ No newline at end of file
Index: .idea/codeStyles/Project.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><component name=\"ProjectCodeStyleConfiguration\">\r\n  <code_scheme name=\"Project\" version=\"173\">\r\n    <DBN-PSQL>\r\n      <case-options enabled=\"true\">\r\n        <option name=\"KEYWORD_CASE\" value=\"lower\" />\r\n        <option name=\"FUNCTION_CASE\" value=\"lower\" />\r\n        <option name=\"PARAMETER_CASE\" value=\"lower\" />\r\n        <option name=\"DATATYPE_CASE\" value=\"lower\" />\r\n        <option name=\"OBJECT_CASE\" value=\"preserve\" />\r\n      </case-options>\r\n      <formatting-settings enabled=\"false\" />\r\n    </DBN-PSQL>\r\n    <DBN-SQL>\r\n      <case-options enabled=\"true\">\r\n        <option name=\"KEYWORD_CASE\" value=\"lower\" />\r\n        <option name=\"FUNCTION_CASE\" value=\"lower\" />\r\n        <option name=\"PARAMETER_CASE\" value=\"lower\" />\r\n        <option name=\"DATATYPE_CASE\" value=\"lower\" />\r\n        <option name=\"OBJECT_CASE\" value=\"preserve\" />\r\n      </case-options>\r\n      <formatting-settings enabled=\"false\">\r\n        <option name=\"STATEMENT_SPACING\" value=\"one_line\" />\r\n        <option name=\"CLAUSE_CHOP_DOWN\" value=\"chop_down_if_statement_long\" />\r\n        <option name=\"ITERATION_ELEMENTS_WRAPPING\" value=\"chop_down_if_not_single\" />\r\n      </formatting-settings>\r\n    </DBN-SQL>\r\n    <DBN-PSQL>\r\n      <case-options enabled=\"true\">\r\n        <option name=\"KEYWORD_CASE\" value=\"lower\" />\r\n        <option name=\"FUNCTION_CASE\" value=\"lower\" />\r\n        <option name=\"PARAMETER_CASE\" value=\"lower\" />\r\n        <option name=\"DATATYPE_CASE\" value=\"lower\" />\r\n        <option name=\"OBJECT_CASE\" value=\"preserve\" />\r\n      </case-options>\r\n      <formatting-settings enabled=\"false\" />\r\n    </DBN-PSQL>\r\n    <DBN-SQL>\r\n      <case-options enabled=\"true\">\r\n        <option name=\"KEYWORD_CASE\" value=\"lower\" />\r\n        <option name=\"FUNCTION_CASE\" value=\"lower\" />\r\n        <option name=\"PARAMETER_CASE\" value=\"lower\" />\r\n        <option name=\"DATATYPE_CASE\" value=\"lower\" />\r\n        <option name=\"OBJECT_CASE\" value=\"preserve\" />\r\n      </case-options>\r\n      <formatting-settings enabled=\"false\">\r\n        <option name=\"STATEMENT_SPACING\" value=\"one_line\" />\r\n        <option name=\"CLAUSE_CHOP_DOWN\" value=\"chop_down_if_statement_long\" />\r\n        <option name=\"ITERATION_ELEMENTS_WRAPPING\" value=\"chop_down_if_not_single\" />\r\n      </formatting-settings>\r\n    </DBN-SQL>\r\n  </code_scheme>\r\n</component>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/codeStyles/Project.xml b/.idea/codeStyles/Project.xml
--- a/.idea/codeStyles/Project.xml	
+++ b/.idea/codeStyles/Project.xml	
@@ -24,29 +24,5 @@
         <option name="ITERATION_ELEMENTS_WRAPPING" value="chop_down_if_not_single" />
       </formatting-settings>
     </DBN-SQL>
-    <DBN-PSQL>
-      <case-options enabled="true">
-        <option name="KEYWORD_CASE" value="lower" />
-        <option name="FUNCTION_CASE" value="lower" />
-        <option name="PARAMETER_CASE" value="lower" />
-        <option name="DATATYPE_CASE" value="lower" />
-        <option name="OBJECT_CASE" value="preserve" />
-      </case-options>
-      <formatting-settings enabled="false" />
-    </DBN-PSQL>
-    <DBN-SQL>
-      <case-options enabled="true">
-        <option name="KEYWORD_CASE" value="lower" />
-        <option name="FUNCTION_CASE" value="lower" />
-        <option name="PARAMETER_CASE" value="lower" />
-        <option name="DATATYPE_CASE" value="lower" />
-        <option name="OBJECT_CASE" value="preserve" />
-      </case-options>
-      <formatting-settings enabled="false">
-        <option name="STATEMENT_SPACING" value="one_line" />
-        <option name="CLAUSE_CHOP_DOWN" value="chop_down_if_statement_long" />
-        <option name="ITERATION_ELEMENTS_WRAPPING" value="chop_down_if_not_single" />
-      </formatting-settings>
-    </DBN-SQL>
   </code_scheme>
 </component>
\ No newline at end of file
Index: .idea/Lineder.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.9 (Lineder - Git)\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/Lineder.iml b/.idea/Lineder.iml
--- a/.idea/Lineder.iml	
+++ b/.idea/Lineder.iml	
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module version="4">
   <component name="NewModuleRootManager">
-    <orderEntry type="jdk" jdkName="Python 3.9 (Lineder - Git)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.9 (Lineder)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.9 (Lineder - Git)\" project-jdk-type=\"Python SDK\" />\r\n  <component name=\"PyCharmProfessionalAdvertiser\">\r\n    <option name=\"shown\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PythonCompatibilityInspectionAdvertiser\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	
+++ b/.idea/misc.xml	
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9 (Lineder - Git)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9 (Lineder)" project-jdk-type="Python SDK" />
   <component name="PyCharmProfessionalAdvertiser">
     <option name="shown" value="true" />
   </component>
